"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionRenderer = void 0;
const os_1 = require("os");
const call_expression_model_1 = require("../../../core/converters/models/converted-items/call-expression.model");
const named_type_model_1 = require("../../../core/converters/models/converted-items/named-type.model");
const type_kind_enum_1 = require("../../../core/converters/models/type-kind.enum");
const utils_1 = require("../../../utils/utils");
class ActionRenderer {
    render(item) {
        return this.toPlantUml(item);
    }
    toPlantUml(item) {
        const fileName = utils_1.getFileName(item.filePath);
        const srcText = fileName ? `src: ${fileName}` : '';
        const createActionArgs = this.createActionArgsToText(item) || '';
        const diagramContent = `interface "${item.name}" << (A,#FF7700) action >> {
            variable: ${item.variable}
            ${srcText}
            --
            ${createActionArgs}
        }

        `;
        return diagramContent;
    }
    typeLiteralToText(typeLiteral) {
        const properties = typeLiteral.properties;
        if (properties && properties.length > 0) {
            const typePrefix = properties.length === 1 ? '' : '\\t';
            const propertiesText = properties.map(p => `${typePrefix}${p.name}: ${p.type}`).join(os_1.EOL);
            if (properties.length === 1) {
                return `{${propertiesText}}`;
            }
            else {
                return `{${os_1.EOL}${propertiesText}${os_1.EOL}}`;
            }
        }
        return;
    }
    callExpressionToText(callExpression) {
        if (!callExpression.typeArguments) {
            return;
        }
        const mappedArgs = [];
        for (const arg of callExpression.typeArguments) {
            switch (arg.kind) {
                case type_kind_enum_1.TypeKind.TypeLiteral:
                    mappedArgs.push(this.typeLiteralToText(arg));
                    break;
                case type_kind_enum_1.TypeKind.TypeReference:
                    mappedArgs.push(arg.name);
                    break;
                default:
                    mappedArgs.push(arg.kindText);
            }
        }
        return `${callExpression.name}<${mappedArgs.join(', ')}>`;
    }
    createActionArgsToText(item) {
        if (item.createActionArgs && item.createActionArgs.length) {
            let resultText = '';
            for (const arg of item.createActionArgs) {
                if (arg instanceof call_expression_model_1.CallExpression) {
                    resultText += this.callExpressionToText(arg) + os_1.EOL;
                }
                else if (arg instanceof named_type_model_1.NamedType) {
                    resultText += `createFunction: ${arg.name || ''} ${arg.kindText || ''}`;
                }
            }
            return resultText;
        }
        return;
    }
}
exports.ActionRenderer = ActionRenderer;
