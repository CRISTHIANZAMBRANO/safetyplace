"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionReferenceConverter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const loglevel_1 = __importDefault(require("loglevel"));
const typescript_1 = __importDefault(require("typescript"));
const models_1 = require("../../../core/converters/models");
const node_converter_1 = require("../../../core/converters/node.converter");
const tsutils_1 = __importStar(require("../../../utils/tsutils"));
const utils_1 = require("../../../utils/utils");
const action_reference_model_1 = require("../../models/action-reference.model");
class ActionReferenceConverter extends node_converter_1.NodeConverter {
    convert(context, node) {
        if (!node.parent
            || typescript_1.default.isVariableDeclaration(node.parent)
            || typescript_1.default.isImportSpecifier(node.parent) // ignore imports
        ) {
            return;
        }
        const symbol = tsutils_1.default.getAliasedSymbol(node, context.typeChecker);
        if (symbol) {
            const action = context.getItem(models_1.TypeKind.Action, symbol);
            if (action) {
                loglevel_1.default.debug(`Found Action use: "${chalk_1.default.yellow(action.name)}" in ${chalk_1.default.gray(node.getSourceFile().fileName)}`);
                loglevel_1.default.trace('name:', node.getText());
                const reference = this.serializeActionUse(context, action, node, symbol);
                return reference;
            }
        }
        return;
    }
    declarationContext(context, action, node) {
        var _a;
        const contextStack = [];
        let currentNode = node;
        while (currentNode) {
            if (typescript_1.default.isVariableDeclaration(currentNode)) {
                const symbol = context.typeChecker.getSymbolAtLocation(currentNode.name);
                if (symbol) {
                    const reducer = context.getItem(models_1.TypeKind.Reducer, symbol);
                    if (reducer) {
                        reducer.addAction(action);
                    }
                }
            }
            switch (currentNode.kind) {
                case typescript_1.default.SyntaxKind.ClassDeclaration:
                case typescript_1.default.SyntaxKind.PropertyDeclaration:
                case typescript_1.default.SyntaxKind.VariableDeclaration:
                case typescript_1.default.SyntaxKind.FunctionDeclaration:
                case typescript_1.default.SyntaxKind.MethodDeclaration: {
                    const declaration = currentNode;
                    contextStack.push({ kindText: tsutils_1.syntaxKindText(currentNode), name: (_a = declaration.name) === null || _a === void 0 ? void 0 : _a.getText() });
                    break;
                }
            }
            currentNode = currentNode.parent;
        }
        return contextStack.reverse();
    }
    serializeSymbol(context, symbol) {
        const reference = new action_reference_model_1.ActionReference(symbol.getName());
        reference.documentation = typescript_1.default.displayPartsToString(symbol.getDocumentationComment(context.typeChecker));
        reference.type = context.typeChecker.typeToString(context.typeChecker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration));
        return reference;
    }
    serializeActionUse(context, action, node, symbol) {
        const reference = this.serializeSymbol(context, symbol);
        reference.isCall = this.isActionCall(node);
        reference.action = action;
        reference.filePath = node.getSourceFile().fileName;
        reference.fileName = utils_1.getFileName(reference.filePath);
        reference.declarationContext = this.declarationContext(context, action, node);
        action.addReference(reference);
        return reference;
    }
    isActionCall(node) {
        return node.parent && typescript_1.default.isCallExpression(node.parent) && node.parent.expression === node;
    }
}
exports.ActionReferenceConverter = ActionReferenceConverter;
