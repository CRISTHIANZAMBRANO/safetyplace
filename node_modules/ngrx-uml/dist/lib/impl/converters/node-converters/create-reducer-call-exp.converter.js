"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateReducerCallExpConverter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const loglevel_1 = __importDefault(require("loglevel"));
const typescript_1 = __importDefault(require("typescript"));
const node_converter_1 = require("../../../core/converters/node.converter");
const tsutils_1 = require("../../../utils/tsutils");
const reducer_model_1 = require("../../models/reducer.model");
const createReducerName = 'createReducer';
class CreateReducerCallExpConverter extends node_converter_1.NodeConverter {
    convert(context, node) {
        if (this.isCreateReducer(node)) {
            const reducer = new reducer_model_1.Reducer(node.getSourceFile().fileName, node.getStart(), node.getEnd());
            loglevel_1.default.debug(`Found reducer in ${chalk_1.default.gray(reducer.filePath)}`);
            const extractedArgs = this.extractArguments(context, node.arguments);
            reducer.state = extractedArgs.state;
            return reducer;
        }
        return;
    }
    isCreateReducer(callExpression) {
        return tsutils_1.getCallExpressionName(callExpression) === createReducerName;
    }
    extractArguments(context, args) {
        const [initialState] = args;
        const state = this.getState(context, initialState);
        // const convertedOns = ons.map(on => context.converter.convertNode(context, on)).filter(on => on);
        return { state };
    }
    convertType(_context, typeNode) {
        const type = _context.typeChecker.getTypeFromTypeNode(typeNode);
        return _context.typeChecker.typeToString(type);
    }
    convertMember(context, node) {
        var _a;
        switch (node.kind) {
            case typescript_1.default.SyntaxKind.PropertySignature: {
                const propertySignature = node;
                const name = (_a = node.symbol) === null || _a === void 0 ? void 0 : _a.name;
                const type = propertySignature.type && this.convertType(context, propertySignature.type);
                return { name, type };
            }
            default:
                loglevel_1.default.warn(`getMember - unknown node kind ${tsutils_1.syntaxKindText(node)}`);
                break;
        }
        return undefined;
    }
    getState(context, node) {
        switch (node.kind) {
            case typescript_1.default.SyntaxKind.Identifier: {
                const identifer = node;
                const symbol = context.typeChecker.getSymbolAtLocation(identifer);
                if (symbol) {
                    const type = context.typeChecker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
                    if (type) {
                        const properties = context.typeChecker.getPropertiesOfType(type);
                        const props = properties.map(p => this.convertMember(context, p.valueDeclaration)).filter(m => m);
                        return { name: context.typeChecker.typeToString(type), properties: props };
                    }
                }
                else {
                    loglevel_1.default.warn('getState - no Identifier symbol', identifer.getText());
                }
                break;
            }
            default:
                loglevel_1.default.warn(`getState - unknown node kind ${tsutils_1.syntaxKindText(node)}`);
                break;
        }
        return;
    }
}
exports.CreateReducerCallExpConverter = CreateReducerCallExpConverter;
