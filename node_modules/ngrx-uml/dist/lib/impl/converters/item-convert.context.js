"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemConvertContext = void 0;
const utils_1 = require("../../utils");
class ItemConvertContext {
    constructor(name, program, typeChecker, converter, rootKinds, lastContext, onFinish) {
        this.name = name;
        this.program = program;
        this.typeChecker = typeChecker;
        this.converter = converter;
        this.rootKinds = rootKinds;
        this.onFinish = onFinish;
        if (lastContext) {
            this.result = lastContext.getRawResult();
        }
        else {
            this.result = new Map();
        }
    }
    finish() {
        if (this.onFinish) {
            this.onFinish(this);
        }
    }
    getRawResult() {
        return this.result;
    }
    getResult() {
        const resultMap = new Map();
        for (const [kind, map] of this.result.entries()) {
            resultMap.set(kind, [...map.values()]);
        }
        return resultMap;
    }
    addResult(itemWithSymbol) {
        let map = this.result.get(itemWithSymbol.item.kind);
        if (!map) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            map = new Map();
            this.result.set(itemWithSymbol.item.kind, map);
        }
        map.set(itemWithSymbol.symbol, itemWithSymbol.item);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    getItem(kind, symbol) {
        const reducersMap = this.result.get(kind);
        if (reducersMap) {
            return reducersMap.get(symbol);
        }
        return;
    }
    serializeResultToJson(parent) {
        // TODO: configurable keyReplacer
        return utils_1.serializeConvertedItemsMapToJson(this.getResult(), parent, utils_1.getKeysReplacer(['action', 'reducerSymbol']));
    }
    isRootKind(kind) {
        return this.rootKinds.includes(kind);
    }
}
exports.ItemConvertContext = ItemConvertContext;
