"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareToPrintChilds = exports.printNode = exports.prepareToPrint = void 0;
const util_1 = __importDefault(require("util"));
const tsutils_1 = require("./tsutils");
function createNodeObj(node) {
    const anyNode = node;
    return anyNode.kind ? { kindText: `${tsutils_1.syntaxKindText(anyNode) || ''} (${anyNode.kind})` } : {};
}
function prepareToPrint(node) {
    if (!node) {
        return undefined;
    }
    const ignoreKeys = ['parent',
        'pos',
        'end',
        'flags',
        'modifierFlagsCache',
        'transformFlags',
        'flowNode',
        'kind',
        'checker'
    ];
    const refs = [];
    function prepare(node, level = 0) {
        if (refs.includes(node)) {
            const anyNode = node;
            return `circular [${anyNode.id || ''}/${anyNode.kind || ''}]`;
        }
        refs.push(node);
        const reduced = Object.entries(node)
            .filter(([key]) => !ignoreKeys.includes(key))
            .reduce((acc, [key, value]) => {
            if (Array.isArray(value)) {
                value = value.map(v => prepare(v, level + 1));
            }
            else {
                if (typeof value === 'object') {
                    value = prepare(value, level + 1);
                }
            }
            if (value) {
                acc[key] = value;
            }
            return acc;
        }, createNodeObj(node));
        return reduced;
    }
    return prepare(node);
}
exports.prepareToPrint = prepareToPrint;
function printNode(node, level = 3) {
    return node && util_1.default.inspect(prepareToPrint(node), false, level, true);
}
exports.printNode = printNode;
function prepareToPrintChilds(node) {
    if (!node) {
        return undefined;
    }
    function prepare(node, level = 0) {
        const reduced = { kindText: tsutils_1.syntaxKindText(node) };
        const childs = node.getChildren().map(child => prepare(child, level + 1));
        if (childs.length) {
            reduced.childs = childs;
        }
        return reduced;
    }
    return prepare(node);
}
exports.prepareToPrintChilds = prepareToPrintChilds;
// export function prepareToPrint(node: ts.Node): unknown {
//     const ignoreKeys = ['parent', 'pos', 'end', 'flags', 'modifierFlagsCache', 'transformFlags', 'flowNode'];
//     const refs: ts.Node[] = [];
//     function prepareNode(node: ts.Node, level = 0): unknown {
//         if (refs.includes(node)) {
//             return 'circular';
//         }
//         refs.push(node);
//         const reduced = Object.entries(node)
//             .filter(([key]) => !ignoreKeys.includes(key))
//             .reduce((acc, [key, value]) => {
//                 if (Array.isArray(value)) {
//                     value = value.map(v => prepareNode(v, level + 1));
//                 } else {
//                     if (typeof value === 'object') {
//                         value = prepareNode(value, level + 1);
//                     }
//                 }
//                 acc[key] = value;
//                 return acc;
//             }, { kindText: syntaxKindText(node) } as { [key: string]: unknown });
//         return reduced;
//     }
//     return prepareNode(node);
// }
