"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSymbol = exports.createTsProgram = exports.getCallExpressionName = exports.syntaxKindText = void 0;
const chalk_1 = __importDefault(require("chalk"));
const loglevel_1 = __importDefault(require("loglevel"));
const typescript_1 = __importDefault(require("typescript"));
function syntaxKindText(element) {
    return typescript_1.default.SyntaxKind[element.kind];
}
exports.syntaxKindText = syntaxKindText;
function getCallExpressionName(callExpression) {
    return typescript_1.default.isIdentifier(callExpression.expression) ? callExpression.expression.text : undefined;
}
exports.getCallExpressionName = getCallExpressionName;
function readConfigFile(baseDir, configName) {
    const configFileName = typescript_1.default.findConfigFile(baseDir, typescript_1.default.sys.fileExists, configName);
    if (!configFileName) {
        const errMsg = `Can't find ts-config file: '${configName}', baseDir: '${baseDir}'`;
        loglevel_1.default.error('Error', chalk_1.default.red(errMsg));
        throw new Error(errMsg);
    }
    loglevel_1.default.info(chalk_1.default.yellow(`Use ts-config file: ${configFileName}`));
    return typescript_1.default.readConfigFile(configFileName, typescript_1.default.sys.readFile);
}
function createTsProgram(fileNames, baseDir, configName) {
    loglevel_1.default.debug(chalk_1.default.yellowBright('baseDir:'), baseDir, chalk_1.default.yellowBright('configName:'), configName);
    const configFileRef = readConfigFile(baseDir, configName);
    if (configFileRef.error) {
        loglevel_1.default.warn(configFileRef.error.messageText);
    }
    loglevel_1.default.trace('configFile', configFileRef.config);
    const parseConfigHost = {
        fileExists: typescript_1.default.sys.fileExists,
        readFile: typescript_1.default.sys.readFile,
        readDirectory: typescript_1.default.sys.readDirectory,
        useCaseSensitiveFileNames: true
    };
    const compilerOptions = typescript_1.default.parseJsonConfigFileContent(configFileRef.config, parseConfigHost, baseDir);
    loglevel_1.default.trace(chalk_1.default.yellow('CompilerOptions:'), compilerOptions.options);
    const program = typescript_1.default.createProgram(fileNames, compilerOptions.options);
    return program;
}
exports.createTsProgram = createTsProgram;
function isSymbol(object) {
    return object.valueDeclaration != null;
}
exports.isSymbol = isSymbol;
function getAliasedSymbol(node, typeChecker) {
    let nameSymbol = typeChecker.getSymbolAtLocation(node);
    if (nameSymbol && nameSymbol.flags & typescript_1.default.SymbolFlags.AliasExcludes) {
        const aliasedSymbol = typeChecker.getAliasedSymbol(nameSymbol);
        if (!typeChecker.isUnknownSymbol(aliasedSymbol)) {
            nameSymbol = aliasedSymbol;
        }
    }
    return nameSymbol;
}
const tsutils = {
    syntaxKindText,
    getCallExpressionName,
    createTsProgram,
    isSymbol,
    getAliasedSymbol
};
exports.default = tsutils;
