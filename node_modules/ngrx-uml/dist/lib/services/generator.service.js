"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorService = void 0;
const chalk_1 = __importDefault(require("chalk"));
const loglevel_1 = __importDefault(require("loglevel"));
const path_1 = __importDefault(require("path"));
const converter_1 = require("../core/converters/converter");
const glob_1 = require("../utils/glob");
const tsutils_1 = require("../utils/tsutils");
const utils_1 = require("../utils/utils");
class GeneratorService {
    constructor(convertFactories, renderer, outputs, options) {
        this.convertFactories = convertFactories;
        this.renderer = renderer;
        this.outputs = outputs;
        this.options = {
            saveConvertResultToJson: false,
            saveWsd: false,
            outDir: '/out',
            baseDir: './',
            tsConfigFileName: 'tsconfig.json',
            clickableLinks: false,
            ignorePattern: '../**/*spec.ts',
            generateImages: true
        };
        if (options) {
            this.options = Object.assign(Object.assign({}, this.options), options);
        }
        if (this.options.logLevel) {
            loglevel_1.default.setLevel(this.options.logLevel);
        }
    }
    generate(filesPattern) {
        return __awaiter(this, void 0, void 0, function* () {
            loglevel_1.default.info('Starting...');
            loglevel_1.default.debug(chalk_1.default.yellow('filePattern:'), filesPattern);
            loglevel_1.default.debug(chalk_1.default.yellow('baseDir:'), this.options.baseDir);
            loglevel_1.default.debug(chalk_1.default.yellow('tsConfig:'), this.options.tsConfigFileName);
            loglevel_1.default.debug('options', this.options);
            if (this.options.baseDir == null || !this.options.tsConfigFileName || !this.options.outDir) {
                loglevel_1.default.warn(`baseDir [${this.options.baseDir}] & tsConfigFileName [${this.options.tsConfigFileName}] & outDir [${this.options.outDir}] must be specified`);
                return;
            }
            if (this.options.baseDir === '') {
                this.options.baseDir = './';
            }
            else if (!this.options.baseDir.endsWith('/')) {
                this.options.baseDir += '/';
            }
            const program = this.createTsProgram(filesPattern, this.options.baseDir, this.options.tsConfigFileName);
            const convertedItems = this.convert(program, this.options.outDir);
            loglevel_1.default.info('Items converted');
            if (!convertedItems) {
                return;
            }
            const renderResult = this.render(convertedItems);
            loglevel_1.default.info('Items rendered');
            if (!renderResult) {
                return;
            }
            yield this.transform(renderResult);
            loglevel_1.default.info('Items transformed');
        });
    }
    createTsProgram(filesPattern, baseDir, tsConfigFileName) {
        const sourceFilePattern = filesPattern;
        const files = glob_1.globSync(sourceFilePattern, {
            ignore: this.options.ignorePattern,
            cwd: this.options.baseDir,
            absolute: true
        });
        loglevel_1.default.debug('Used source files', files);
        const program = tsutils_1.createTsProgram(files, baseDir, tsConfigFileName);
        return program;
    }
    convert(program, outDir) {
        const converter = new converter_1.Converter();
        const typeChecker = program.getTypeChecker();
        let converterResult = undefined;
        let lastContext = undefined;
        for (const contextFactory of this.convertFactories) {
            const context = contextFactory.create(program, typeChecker, converter, lastContext);
            converterResult = converter.convert(context, program);
            this.saveConvertResult(context, outDir);
            lastContext = context;
        }
        return converterResult;
    }
    saveConvertResult(context, outDir) {
        if (this.options.saveConvertResultToJson) {
            const result = context.serializeResultToJson({ rootPath: this.options.baseDir });
            if (result) {
                for (const { kind, json } of result) {
                    const filePath = utils_1.writeToFile(json, path_1.default.join(outDir, 'json'), `${context.name}_${kind}.json`);
                    loglevel_1.default.info(`Convert result saved to: ${chalk_1.default.gray(filePath)}`);
                }
            }
        }
    }
    render(items) {
        return this.renderer.render(items);
    }
    transform(input) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const output of this.outputs) {
                yield output.transform(input);
            }
        });
    }
}
exports.GeneratorService = GeneratorService;
